use crate::error::{ConnectedError, Result};
use rcgen::{CertifiedKey, generate_simple_self_signed};
use rustls::pki_types::{CertificateDer, PrivatePkcs8KeyDer};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;
use tracing::info;

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub enum PeerStatus {
    /// Device is trusted and can connect/transfer freely
    Trusted,
    /// Device is blocked - cannot connect even in pairing mode
    Blocked,
    /// Device was forgotten - completely removed, requires full pairing request flow
    Forgotten,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct PeerInfo {
    pub fingerprint: String,
    pub status: PeerStatus,
    pub device_id: Option<String>,
    pub name: Option<String>,
    pub last_seen: u64,
}

#[derive(Serialize, Deserialize, Default, Debug)]
struct KnownPeers {
    // Fingerprint -> PeerInfo
    peers: HashMap<String, PeerInfo>,
}

#[derive(Debug)]
pub struct KeyStore {
    cert: CertificateDer<'static>,
    key: PrivatePkcs8KeyDer<'static>,
    device_id: String,
    known_peers: KnownPeers,
    storage_dir: PathBuf,
    pairing_mode: bool,
}

impl KeyStore {
    pub fn new(custom_path: Option<PathBuf>) -> Result<Self> {
        let storage_dir = if let Some(p) = custom_path {
            p
        } else {
            dirs::config_dir()
                .ok_or_else(|| {
                    ConnectedError::InitializationError("Could not find config dir".to_string())
                })?
                .join("connected")
        };

        if !storage_dir.exists() {
            std::fs::create_dir_all(&storage_dir).map_err(|e| ConnectedError::Io(e))?;
        }

        let (cert, key, device_id) = Self::load_or_create_identity(&storage_dir)?;
        let known_peers = Self::load_known_peers(&storage_dir)?;

        Ok(Self {
            cert,
            key,
            device_id,
            known_peers,
            storage_dir,
            pairing_mode: false,
        })
    }

    pub fn device_id(&self) -> &str {
        &self.device_id
    }

    fn load_or_create_identity(
        storage_dir: &PathBuf,
    ) -> Result<(CertificateDer<'static>, PrivatePkcs8KeyDer<'static>, String)> {
        let identity_path = storage_dir.join("identity.json");

        if identity_path.exists() {
            return Self::load_identity_der(&identity_path);
        }

        info!("No identity found, generating new one...");
        let CertifiedKey { cert, key_pair } = generate_simple_self_signed(vec![
            "connected.local".to_string(),
            "localhost".to_string(),
        ])
        .map_err(|e| ConnectedError::InitializationError(e.to_string()))?;

        let cert_der = cert.der().to_vec();
        let key_der = key_pair.serialize_der();
        let device_id = uuid::Uuid::new_v4().to_string();

        // Save
        let persisted = PersistedIdentityDer {
            cert_der: cert_der.clone(),
            key_der: key_der.clone(),
            device_id: device_id.clone(),
        };
        let data = serde_json::to_vec_pretty(&persisted)
            .map_err(|e| ConnectedError::InitializationError(e.to_string()))?;
        std::fs::write(&identity_path, data).map_err(ConnectedError::Io)?;

        Ok((
            CertificateDer::from(cert_der),
            PrivatePkcs8KeyDer::from(key_der),
            device_id,
        ))
    }

    fn load_identity_der(
        path: &PathBuf,
    ) -> Result<(CertificateDer<'static>, PrivatePkcs8KeyDer<'static>, String)> {
        let data = std::fs::read(path).map_err(ConnectedError::Io)?;
        let persisted: PersistedIdentityDer = serde_json::from_slice(&data).map_err(|e| {
            ConnectedError::InitializationError(format!("Failed to parse identity: {}", e))
        })?;

        // Check if device_id was missing (generated by serde default)
        // We need to check the raw JSON to see if it was actually present
        let raw_json: serde_json::Value = serde_json::from_slice(&data).unwrap_or_default();
        let had_device_id = raw_json.get("device_id").is_some();

        if !had_device_id {
            // device_id was generated by default, save it back to persist it
            info!(
                "Legacy identity file missing device_id, persisting generated id: {}",
                persisted.device_id
            );
            let updated_data = serde_json::to_vec_pretty(&persisted)
                .map_err(|e| ConnectedError::InitializationError(e.to_string()))?;
            std::fs::write(path, updated_data).map_err(ConnectedError::Io)?;
        }

        Ok((
            CertificateDer::from(persisted.cert_der),
            PrivatePkcs8KeyDer::from(persisted.key_der),
            persisted.device_id,
        ))
    }

    fn load_known_peers(storage_dir: &PathBuf) -> Result<KnownPeers> {
        let new_path = storage_dir.join("known_peers.json");

        if new_path.exists() {
            let data = std::fs::read(&new_path).map_err(ConnectedError::Io)?;
            let peers: KnownPeers = serde_json::from_slice(&data).unwrap_or_default();
            Ok(peers)
        } else {
            Ok(KnownPeers::default())
        }
    }

    fn save_peers(&self) -> Result<()> {
        let data = serde_json::to_vec_pretty(&self.known_peers)
            .map_err(|e| ConnectedError::InitializationError(e.to_string()))?;
        std::fs::write(self.storage_dir.join("known_peers.json"), data)
            .map_err(ConnectedError::Io)?;
        Ok(())
    }

    pub fn trust_peer(
        &mut self,
        fingerprint: String,
        device_id: Option<String>,
        name: Option<String>,
    ) -> Result<()> {
        self.known_peers.peers.insert(
            fingerprint.clone(),
            PeerInfo {
                fingerprint,
                status: PeerStatus::Trusted,
                device_id,
                name,
                last_seen: std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap_or_default()
                    .as_secs(),
            },
        );
        self.save_peers()
    }

    pub fn block_peer(&mut self, fingerprint: String) -> Result<()> {
        if let Some(peer) = self.known_peers.peers.get_mut(&fingerprint) {
            peer.status = PeerStatus::Blocked;
        } else {
            self.known_peers.peers.insert(
                fingerprint.clone(),
                PeerInfo {
                    fingerprint,
                    status: PeerStatus::Blocked,
                    device_id: None,
                    name: None,
                    last_seen: std::time::SystemTime::now()
                        .duration_since(std::time::UNIX_EPOCH)
                        .unwrap_or_default()
                        .as_secs(),
                },
            );
        }
        self.save_peers()
    }

    /// Remove peer completely from known peers list
    /// This allows re-pairing without any restrictions
    pub fn remove_peer(&mut self, fingerprint: &str) -> Result<()> {
        if self.known_peers.peers.remove(fingerprint).is_some() {
            self.save_peers()
        } else {
            Ok(())
        }
    }

    /// Remove peer by device_id
    pub fn remove_peer_by_id(&mut self, device_id: &str) -> Result<()> {
        let fingerprint = self
            .known_peers
            .peers
            .values()
            .find(|p| p.device_id.as_deref() == Some(device_id))
            .map(|p| p.fingerprint.clone());

        if let Some(fp) = fingerprint {
            self.remove_peer(&fp)
        } else {
            Ok(())
        }
    }

    /// Forget a peer - removes trust but keeps record to prevent auto-repairing
    /// The peer will need to go through pairing request flow again
    pub fn forget_peer(&mut self, fingerprint: String) -> Result<()> {
        if let Some(peer) = self.known_peers.peers.get_mut(&fingerprint) {
            peer.status = PeerStatus::Forgotten;
            peer.last_seen = std::time::SystemTime::now()
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap_or_default()
                .as_secs();
        } else {
            // If not known, add as forgotten to prevent auto-trust
            self.known_peers.peers.insert(
                fingerprint.clone(),
                PeerInfo {
                    fingerprint,
                    status: PeerStatus::Forgotten,
                    device_id: None,
                    name: None,
                    last_seen: std::time::SystemTime::now()
                        .duration_since(std::time::UNIX_EPOCH)
                        .unwrap_or_default()
                        .as_secs(),
                },
            );
        }
        self.save_peers()
    }

    /// Forget peer by device_id
    pub fn forget_peer_by_id(&mut self, device_id: &str) -> Result<()> {
        let fingerprint = self
            .known_peers
            .peers
            .values()
            .find(|p| p.device_id.as_deref() == Some(device_id))
            .map(|p| p.fingerprint.clone());

        if let Some(fp) = fingerprint {
            self.forget_peer(fp)
        } else {
            Ok(())
        }
    }

    pub fn get_cert(&self) -> CertificateDer<'static> {
        self.cert.clone()
    }

    pub fn get_key(&self) -> PrivatePkcs8KeyDer<'static> {
        self.key.clone_key()
    }

    pub fn is_trusted(&self, fingerprint: &str) -> bool {
        if let Some(peer) = self.known_peers.peers.get(fingerprint) {
            return peer.status == PeerStatus::Trusted;
        }
        false
    }

    pub fn is_blocked(&self, fingerprint: &str) -> bool {
        if let Some(peer) = self.known_peers.peers.get(fingerprint) {
            return peer.status == PeerStatus::Blocked;
        }
        false
    }

    /// Check if peer was forgotten (requires re-pairing with user confirmation)
    pub fn is_forgotten(&self, fingerprint: &str) -> bool {
        if let Some(peer) = self.known_peers.peers.get(fingerprint) {
            return peer.status == PeerStatus::Forgotten;
        }
        false
    }

    /// Check if peer should trigger a pairing request (unknown or forgotten)
    pub fn needs_pairing_request(&self, fingerprint: &str) -> bool {
        match self.known_peers.peers.get(fingerprint) {
            None => true, // Unknown peer
            Some(peer) => peer.status == PeerStatus::Forgotten,
        }
    }

    pub fn get_peer_name(&self, fingerprint: &str) -> Option<String> {
        self.known_peers
            .peers
            .get(fingerprint)
            .and_then(|p| p.name.clone())
    }

    // Legacy support / Convenience
    pub fn is_known_fingerprint(&self, fingerprint: &str) -> bool {
        self.known_peers.peers.contains_key(fingerprint)
    }

    pub fn fingerprint(&self) -> String {
        use sha2::{Digest, Sha256};
        let mut hasher = Sha256::new();
        hasher.update(&self.cert);
        format!("{:x}", hasher.finalize())
    }

    // Pairing Mode Controls
    pub fn set_pairing_mode(&mut self, enabled: bool) {
        self.pairing_mode = enabled;
        info!("Pairing mode set to: {}", enabled);
    }

    pub fn is_pairing_mode(&self) -> bool {
        self.pairing_mode
    }

    pub fn get_trusted_peers(&self) -> Vec<PeerInfo> {
        self.known_peers
            .peers
            .values()
            .filter(|p| p.status == PeerStatus::Trusted)
            .cloned()
            .collect()
    }

    pub fn get_forgotten_peers(&self) -> Vec<PeerInfo> {
        self.known_peers
            .peers
            .values()
            .filter(|p| p.status == PeerStatus::Forgotten)
            .cloned()
            .collect()
    }

    pub fn get_blocked_peers(&self) -> Vec<PeerInfo> {
        self.known_peers
            .peers
            .values()
            .filter(|p| p.status == PeerStatus::Blocked)
            .cloned()
            .collect()
    }

    pub fn get_all_known_peers(&self) -> Vec<PeerInfo> {
        self.known_peers.peers.values().cloned().collect()
    }
}

#[derive(Serialize, Deserialize)]
struct PersistedIdentityDer {
    cert_der: Vec<u8>,
    key_der: Vec<u8>,
    #[serde(default = "default_device_id")]
    device_id: String,
}

fn default_device_id() -> String {
    uuid::Uuid::new_v4().to_string()
}
